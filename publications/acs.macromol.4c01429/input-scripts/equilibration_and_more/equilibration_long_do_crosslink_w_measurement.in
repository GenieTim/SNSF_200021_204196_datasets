#LAMMPS input file: Calculate the modulus from autocorrelation

units           lj
atom_style      angle
special_bonds   fene

bond_style      fene

pair_style	lj/cut 1.12246
angle_style fourier/simple
echo both

read_data       &structure-file extra/bond/per/atom 4 extra/special/per/atom 48 extra/angle/per/atom 8 

change_box      all triclinic

neighbor        0.95 bin
neigh_modify    every 2 delay 0 check yes

bond_coeff	1 30.0 1.5 1.0 1.0
angle_coeff 	1 0.013 -1.0 1.0
pair_coeff  * * 1.0 1.0 1.12246
pair_modify     shift yes

fix             1 all nve
fix             2 all langevin 1.0 1.0 0.5 394710 # zero yes

group xlinks type 2

# prevent errors due to missing angle atoms
comm_modify     mode single cutoff 3.2 vel yes

timestep 0.001
thermo 10
run 10000

timestep 0.01 # 0.006

# pseudo-equilibration
thermo 50
run 1000000 # 1e6
reset_timestep 0

# after first run, we can reduce comm req.
comm_modify     mode single cutoff 2.5 vel no

# dump coordinates regularly to externally calculate Ree and Rgyr
dump		1 all custom 750000 &output-folder/&output-basename.dump.out id type x y z ix iy iz # id = atom id, type = atom type, (x|y|z)su are coordinates without periodic boundary scaled by box size

compute allBondLen all bond/local dist
compute maxBondLen all reduce max c_allBondLen
compute aveBondLen all reduce ave c_allBondLen

restart 100000 &output-folder/&output-basename.restart-1.out &output-folder/&output-basename.restart-2.out

thermo 5000
run 1000000 # 1e6


# compute stresses
compute pA all pressure thermo_temp
compute pAv all pressure NULL virial

variable nxy equal c_pA[1]-c_pA[2]
variable nxz equal c_pA[1]-c_pA[3]
variable nyz equal c_pA[2]-c_pA[3]

variable nxyv equal c_pAv[1]-c_pAv[2]
variable nxzv equal c_pAv[1]-c_pAv[3]
variable nyzv equal c_pAv[2]-c_pAv[3]

fix 5 all ave/correlate/long 1 500000 c_pA[1] c_pA[2] c_pA[3] c_pA[4] c_pA[5] c_pA[6] v_nxy v_nxz v_nyz type auto nlen 16 ncount 2 ncorr 30 file &output-folder/&output-basename.out.correlate-withkin.txt

fix 7 all ave/time 1 5000 5000 c_pA[1] c_pA[2] c_pA[3] c_pA[4] c_pA[5] c_pA[6] v_nxy v_nxz v_nyz mode scalar ave one file &output-folder/&output-basename.out.ave-withkin.txt

run 400000000 # 4e8 equilibration

unfix 5
unfix 7

# compute degree of convergence
compute nxlinks all count/type atom
variable nxlinks equal c_nxlinks[2]
compute		bondsperatom all property/atom nbonds
compute		nbonds all reduce sum c_bondsperatom
variable nbonds0 equal c_nbonds
variable	xlinkerConversion equal (c_nbonds-${nbonds0})/(4*${nxlinks})
variable chainConversion equal (c_nbonds-${nbonds0})/(&nmonochains+2*&nchains)
# take max
variable relevantConversion equal (v_xlinkerConversion*(v_xlinkerConversion>v_chainConversion)+v_chainConversion*(v_chainConversion>=v_xlinkerConversion))
# take mean
variable irrelevantConversion equal (v_xlinkerConversion*(v_xlinkerConversion<v_chainConversion)+v_chainConversion*(v_chainConversion<=v_xlinkerConversion))

variable tstep equal step

write_data &output-folder/t-${tstep}-&output-basename.structure.out

thermo_style    custom step temp vol press c_maxBondLen c_aveBondLen c_pA[1] c_pA[2] c_pA[3] c_pA[4] c_pA[5] c_pA[6] v_xlinkerConversion

comm_modify     mode single cutoff 2.75 vel no

# start cross-linking
# add bonds
fix 7 all bond/create 25 1 2 1.1 1 iparam 2 1 jparam 4 2 atype 1

variable z loop 1000000 # output often in the beginning, when lots of bonds are made
label loop0
run 50
if "${xlinkerConversion}>=0.80" then "jump SELF loopexit0"
if "${chainConversion}>=0.80" then "jump SELF loopexit0"
next z
jump SELF loop0
label loopexit0

variable a loop 1000000 # output often in the beginning, when lots of bonds are made
label loop1
run 50
if "${xlinkerConversion}>=0.85" then "jump SELF loopexit1"
if "${chainConversion}>=0.85" then "jump SELF loopexit1"
next a
jump SELF loop1
label loopexit1

write_data &output-folder/crosslinked/crosslinked_p_${relevantConversion}_${irrelevantConversion}_&output-basename.structure.out

variable b loop 1000000 # output often in the beginning, when lots of bonds are made
label loop2
run 50
if "${xlinkerConversion}>=0.90" then "jump SELF loopexit2"
if "${chainConversion}>=0.90" then "jump SELF loopexit2"
next b
jump SELF loop2
label loopexit2

write_data &output-folder/crosslinked/crosslinked_p_${relevantConversion}_${irrelevantConversion}_&output-basename.structure.out

variable c loop 1000000 # output often in the beginning, when lots of bonds are made
label loop3
run 75
if "${xlinkerConversion}>=0.95" then "jump SELF loopexit3"
if "${chainConversion}>=0.95" then "jump SELF loopexit3"
next c
jump SELF loop3
label loopexit3

write_data &output-folder/crosslinked/crosslinked_p_${relevantConversion}_${irrelevantConversion}_&output-basename.structure.out

unfix 7
fix 7 all bond/create 5 1 2 1.1 1 iparam 2 1 jparam 4 2 atype 1

variable d loop 5000000 # output often in the beginning, when lots of bonds are made
label loop4
run 50
if "${xlinkerConversion}>=0.98" then "jump SELF loopexit4"
if "${chainConversion}>=0.98" then "jump SELF loopexit4"
next d
jump SELF loop4
label loopexit4

write_data &output-folder/crosslinked/crosslinked_p_${relevantConversion}_${irrelevantConversion}_&output-basename.structure.out

variable d loop 5000000 # output often in the beginning, when lots of bonds are made
label loop5
run 50
if "${xlinkerConversion}>=1.0" then "jump SELF loopexit5"
if "${chainConversion}>=1.0" then "jump SELF loopexit5"
next d
jump SELF loop5
label loopexit5

write_data &output-folder/crosslinked/crosslinked_p_${relevantConversion}_${irrelevantConversion}_&output-basename.structure.out
